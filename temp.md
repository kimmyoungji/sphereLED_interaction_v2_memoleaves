// AtomicReference<T>는 멀티스레드 환경에서 객체 참조를 원자적으로(atomic) 읽고 쓸 수 있도록 보장하는 클래스이다.
// 즉, 여러 스레드가 동시에 접근하더라도 값의 읽기와 쓰기 연산이 중간에 끼어들지 않고 안전하게 수행된다.
// 따라서 'phase'라는 시스템의 상태 코드를 저장하는 변수를 AtomicReference<T> 타입으로 지정한 이유는
// 상태 전환(read/write)이 여러 스레드에서 동시에 일어날 때 발생할 수 있는 데이터 불일치나 race condition을 예방하기 위함이다.


// Spring Boot 애플리케이션을 'Reactive' 타입(WebFlux 기반)으로 구성한다는 것은
// 서버가 들어오는 요청을 스레드 하나당 하나씩 처리하는 '블로킹(Blocking)' 방식이 아니라,
// 비동기(Asynchronous)·논블로킹(Non-blocking) 방식으로 처리한다는 의미이다.
// 즉, 앞선 요청의 처리를 기다리느라 다음 요청을 수락하지 못하는 일이 줄어든다.


// Reactive Web Application에서는 전통적인 서블릿 컨테이너(Tomcat) 대신
// Netty와 같은 논블로킹 I/O 서버가 사용된다.
// Netty는 이벤트 루프(Event Loop) 기반의 아키텍처로 동작하며,
// 요청을 처리할 때 스레드를 점유한 채로 블로킹하지 않는다.

// 즉, 요청이 들어오면 이벤트 루프가 해당 요청을 큐에 등록하고,
// 실제 I/O나 연산이 완료되면 완료 이벤트(Callback 또는 Future/Mono/Flux 신호)를 통해
// 다시 이벤트 루프가 응답을 처리한다.
// 이로 인해 Netty 서버는 적은 수의 스레드로도 많은 요청을 동시에 처리할 수 있다.
// (Node.js의 이벤트 루프 모델과 유사하다.)

// 요약하자면, Reactive 방식의 Spring WebFlux 서버는
// Netty를 기반으로 비동기·논블로킹 이벤트 루프 구조를 통해
// 효율적인 자원 사용과 높은 동시성을 구현한다.